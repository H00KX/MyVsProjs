#include "stdafx.h"
#include "MyView.h"

#include "glut\glut.h"

int CTank::m_nMovStep = 25;

unsigned char g_mapData[26][26] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00,
    0x01, 0x01, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x01,  0x01,
    0x02, 0x02, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x02,  0x02,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00,	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,  0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x00, 0x01, 0x00,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00,
};



CMyView::CMyView()
{
    //从pcx文件种加载坦克图片素材
    CImageBuf ImageBuf;
    ImageBuf.LoadPcx("data\\object.pcx");

    //获取砖，草等元素
    for (int i = 1; i <= 5; i++)
    {
        ImageBuf.CopyImage(0 + (i - 1) * 25, 256, 25, 25, MapPic[i]);
    }

    for (int i = 0; i < 4; i++)
    {
        ImageBuf.CopyImage(150 + (i + 1) * 50, 50, 50, 49, TankPic[0][i]);             //拷贝上、下、左、右朝向tank
    }

    for (int i = 0; i < 4; i++)
    {
        ImageBuf.CopyImage(150 + (i + 1) * 50, 0, 50, 49, TankPic[1][i]);             //拷贝上、下、左、右朝向tank
    }

    for (int i = 0; i < 4; i++)
    {
        ImageBuf.CopyImage(0 + (i) * 50, 0, 50, 49, TankPic[2][i]);             //拷贝上、下、左、右朝向tank
    }

    for (int i = 0; i < 4; i++)
    {
        ImageBuf.CopyImage(150 + (i + 1) * 50, 201, 50, 49, TankPic[3][i]);             //拷贝上、下、左、右朝向tank
    }

    for (int i = 0; i <= 5; i++)
    {
        ImageBuf.CopyImage(50 + i * 50, 150, 50, 50, BoomPic[i]);                       //for boom
    }

    for (int i = 0; i < 2; i++)
    {
        ImageBuf.CopyImage(i * 15, 150, 15, 15, BulletPic[i]);             //拷贝上、下、左、右朝向tank
    }

    ImageBuf.CopyImage(0, 100, 50, 50, HomeBase);             //拷贝上、下、左、右朝向tank


                                                              //初始化当前的数据
    for (int i = 0; i < 26; i++)
    {
        for (int j = 0; j < 26; j++)
        {
            m_mapData[i][j] = g_mapData[i][j];
        }
    }

    //xy为坦克左下角在地图中的坐标
    m_MyTank.SetCurX(9 * 25);
    m_MyTank.SetCurY(25 * 25);

    RTs[0] = RobotTank(0, 625 - 25, 1);
}


CMyView::~CMyView()
{
}

void CMyView::drawMap()
{

    for (int i = 0; i < 26; i++)
    {
        for (int j = 0; j < 26; j++)
        {
            if (m_mapData[i][j] == 0x01)
            {
                DrawElement(j * 25, (25 - i) * 25, m_mapData[i][j]);
            }
            else if (m_mapData[i][j] == 0x02)
            {
                DrawElement(j * 25, (25 - i) * 25, m_mapData[i][j]);
            }
            else if (m_mapData[i][j] == 0x05)
            {
                DrawElement(j * 25, (25 - i) * 25, m_mapData[i][j]);
            }
            else if (m_mapData[i][j] == 0x06)
            {
                DrawHomeBase(j * 25, (25 - i) * 25);
            }
        }
    }

    //绘图坐标系原点(0,0) 为左下角，x竖直向上，y水平向右
    //开始绘制坦克
    DrawTank(m_MyTank.CurX(),
        (650 - m_MyTank.CurY() - 25),
             m_MyTank.m_nType,
             m_MyTank.m_nRotate);
    DrawTank(RTs[0].CurX(),
        (650 - RTs[0].CurY() - 25),
             RTs[0].m_nType,
             RTs[0].m_nRotate);
}

//CurX,CurY 坦克的左下角 在地图坐标系（原点(0,0)）中的位置

//绘图坐标系原点(0,0) 为左下角，x竖直向上，y水平向右
void CMyView::OnUp()
{
    //上移，Y减小一个步长    nx,ny即为 移动后的预期位置
    int nX = m_MyTank.CurX() / 25;
    int nY = (m_MyTank.CurY() - CTank::m_nMovStep) / 25;

    if (!CheckImpact(nX, nY))
    {
        m_MyTank.OnUp();
    }
}

void CMyView::OnDown()
{
    int nMore = 0;
    int nX = m_MyTank.CurX() / 25;
    int nY = (m_MyTank.CurY() + CTank::m_nMovStep) / 25;

    if (!CheckImpact(nX, nY))
    {
        m_MyTank.OnDown();
    }

}

void CMyView::OnLeft()
{
    int nX = (m_MyTank.CurX() - CTank::m_nMovStep) / 25;
    int nY = m_MyTank.CurY() / 25;

    if (!CheckImpact(nX, nY))
    {
        m_MyTank.OnLeft();
    }

}

void CMyView::OnRight()
{
    int nX = (m_MyTank.CurX() + CTank::m_nMovStep) / 25;
    int nY = m_MyTank.CurY() / 25;

    if (!CheckImpact(nX, nY))
    {
        m_MyTank.OnRight();
    }

}

//返回1，不能走。返回0，击中。返回2，可以走
int CMyView::CheckImpact(int x, int y)
{

    if (x < 0 || x + 1 > 25)
    {
        return 1;
    }

    if (y - 1 < 0 || y > 25)
    {
        return 1;
    }

    if (m_mapData[y][x] != 0x00 ||
        m_mapData[y][x + 1] != 0x00 ||
        m_mapData[y - 1][x] != 0x00 ||
        m_mapData[y - 1][x + 1] != 0x00)
    {
        return 1;
    }

    return 0;
}

void CMyView::AutoRun()
{
    for (int i = 0; i < 4; i++)
    {
        RTs[i].AutoRun();
    }
}

void MixPic(int x, int y, int w, int h, unsigned char *buf)             //glReadPixels 
{
    int PixelByte = 4;        //for RGBA color

    int SrcTempPos = 0, TempPos = 0;
    unsigned char *Temp = new unsigned char[w*h*PixelByte];

    glReadPixels(x, y, w, h, GL_RGB, GL_UNSIGNED_BYTE, Temp);
    glReadPixels(x, y, w, h, GL_RGBA, GL_UNSIGNED_BYTE, Temp);
    for (int i = 0; i < w*h; i++)
    {
        if ((buf[SrcTempPos + 3]) == 0)          //找出了边框为黑色的部分
        {
            memcpy(&buf[SrcTempPos], &Temp[TempPos], 3);         //显示背景色
        }
        SrcTempPos += 4;
        TempPos += PixelByte;
    }
    delete[]Temp;
}

//绘制基本元素， nType = 1 表示砖  2 铁 3 浅蓝方块 4 深蓝方块 5 草 
void CMyView::DrawElement(int x, int y, int nType)
{
    glRasterPos2i(x, y);      //为像素操作指定光栅位置  用25*i j  为了显示图像的不重叠
    MixPic(25, 25, 25, 25, MapPic[nType]);
    glDrawPixels(25, 25, GL_RGBA, GL_UNSIGNED_BYTE, MapPic[nType]);  //将一个像素块写入帧缓存  
}

void CMyView::DrawBg(int x, int y)
{
    //绘制矩形
    glColor3f(0.0f, 0.0f, 0.0f);
    glRectf(x, y, x + 25.0f, y + 25.0f);
}

void CMyView::DrawBoom(int x, int y, int nType)
{

    glRasterPos2i(x, y);      //为像素操作指定光栅位置  用25*i j  为了显示图像的不重叠
    glDrawPixels(50, 50, GL_RGBA, GL_UNSIGNED_BYTE, BoomPic[nType]);  //将一个像素块写入帧缓存  
}

void CMyView::DrawTank(int x, int y, int nType, int nRotate)
{

    glRasterPos2i(x, y);      //为像素操作指定光栅位置  用25*i j  为了显示图像的不重叠
    glDrawPixels(50, 49, GL_RGBA, GL_UNSIGNED_BYTE, TankPic[nType][nRotate]);  //将一个像素块写入帧缓存  
}

void CMyView::DrawHomeBase(int x, int y)
{

    glRasterPos2i(x, y);      //为像素操作指定光栅位置  用25*i j  为了显示图像的不重叠				
    glDrawPixels(50, 50, GL_RGBA, GL_UNSIGNED_BYTE, HomeBase);  //将一个像素块写入帧缓存  

}

void CMyView::DrawBullet(int x, int y, int nType)
{

    glRasterPos2i(x, y);      //为像素操作指定光栅位置  用25*i j  为了显示图像的不重叠
    glDrawPixels(15, 15, GL_RGBA, GL_UNSIGNED_BYTE, BulletPic[nType]);  //将一个像素块写入帧缓存  
}

